type UserInfoExt = 
 record {
   dateOfBirth: text;
   firstName: text;
   id: principal;
   lastName: text;
   liveIn: text;
   phone: text;
   sex: nat;
 };
type TxReceipt__1 = 
 variant {
   Err:
    variant {
      AmountTooSmall;
      BlockUsed;
      ErrorOperationStyle;
      ErrorTo;
      InsufficientAllowance;
      InsufficientBalance;
      LedgerTrap;
      Other: text;
      Unauthorized;
    };
   Ok: nat;
 };
type TxReceipt = 
 variant {
   Err: ApiError;
   Ok: nat;
 };
type TokenId = nat64;
type OwnerResult = 
 variant {
   Err: ApiError;
   Ok: principal;
 };
type NFTSale = 
 service {
   allowance: (principal, principal) -> (nat);
   approve: (principal, nat) -> (TxReceipt__1);
   balanceOf: (principal) -> (nat);
   balanceOfDip721: (principal) -> (nat64) query;
   burn: (nat) -> (TxReceipt__1);
   createAccount: (text, text, nat, text, text, text) -> (UserInfoExt);
   decimals: () -> (nat8) query;
   deleteAccount: (principal) -> (bool);
   getMaxLimitDip721: () -> (nat16) query;
   getMetadataDip721: (TokenId) -> (MetadataResult) query;
   getMetadataForUserDip721: (principal) -> (ExtendedMetadataResult);
   getTokenFee: () -> (nat) query;
   getTokenIdsForUserDip721: (principal) -> (vec TokenId) query;
   getUserInfo: (principal) -> (opt UserInfoExt) query;
   logoDip721: () -> (LogoResult) query;
   logoToken: () -> (text) query;
   mint: (principal, nat) -> (TxReceipt__1);
   mintDip721: (principal, MetadataDesc) -> (MintReceipt);
   nameDip721: () -> (text) query;
   nameToken: () -> (text) query;
   ownerOfDip721: (TokenId) -> (OwnerResult) query;
   readAccount: () -> (vec UserInfoExt) query;
   safeTransferFromDip721: (principal, principal, TokenId) -> (TxReceipt);
   supportedInterfacesDip721: () -> (vec InterfaceId) query;
   symbolDip721: () -> (text) query;
   symbolToken: () -> (text) query;
   totalSupply: () -> (nat) query;
   totalSupplyDip721: () -> (nat64) query;
   transfer: (principal, nat) -> (TxReceipt__1);
   transferFromDip721: (principal, principal, TokenId) -> (TxReceipt);
   updateAccount: (principal, text, text, nat, text, text, text) ->
    (UserInfoExt);
 };
type MintReceiptPart = 
 record {
   id: nat;
   token_id: TokenId;
 };
type MintReceipt = 
 variant {
   Err: ApiError;
   Ok: MintReceiptPart;
 };
type MetadataVal = 
 variant {
   BlobContent: blob;
   Nat16Content: nat16;
   Nat32Content: nat32;
   Nat64Content: nat64;
   Nat8Content: nat8;
   NatContent: nat;
   TextContent: text;
 };
type MetadataResult = 
 variant {
   Err: ApiError;
   Ok: MetadataDesc;
 };
type MetadataPurpose = 
 variant {
   Preview;
   Rendered;
 };
type MetadataPart = 
 record {
   data: blob;
   key_val_data: vec MetadataKeyVal;
   purpose: MetadataPurpose;
 };
type MetadataKeyVal = 
 record {
   key: text;
   val: MetadataVal;
 };
type MetadataDesc = vec MetadataPart;
type LogoResult = 
 record {
   data: text;
   logo_type: text;
 };
type InterfaceId = 
 variant {
   Approval;
   Burn;
   Mint;
   TransactionHistory;
   TransferNotification;
 };
type ExtendedMetadataResult = 
 variant {
   Err: ApiError;
   Ok: record {
         metadata_desc: MetadataDesc;
         token_id: TokenId;
       };
 };
type ApiError = 
 variant {
   InvalidTokenId;
   Other;
   Unauthorized;
   ZeroAddress;
 };
service : (principal) -> NFTSale
