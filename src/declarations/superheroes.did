type UserInfoExt = 
 record {
   dateOfBirth: text;
   firstName: text;
   id: principal;
   lastName: text;
   liveIn: text;
   phone: text;
   sex: nat;
 };
type TxReceipt = 
 variant {
   Err:
    variant {
      AmountTooSmall;
      BlockUsed;
      ErrorOperationStyle;
      ErrorTo;
      InsufficientAllowance;
      InsufficientBalance;
      LedgerTrap;
      Other: text;
      Unauthorized;
    };
   Ok: nat;
 };
type TokenInfoExt = 
 record {
   category: text;
   createdBy: principal;
   date: text;
   dateCreated: text;
   description: text;
   details: text;
   gifts: vec TokenGiftInfo;
   id: text;
   image: text;
   name: text;
   nftType: text;
   owner: principal;
   place: text;
   price: nat;
   time: text;
 };
type TokenGiftInfo = 
 record {
   createdBy: principal;
   description: text;
   id: text;
   image: text;
   name: text;
   price: nat;
 };
type NFTSale = 
 service {
   balanceOf: (principal) -> (nat);
   burnToken: (nat) -> (TxReceipt);
   checkinTicket: (text, principal) -> (text);
   clearAllTokens: () -> () oneway;
   createAccount: (text, text, nat, text, text, text) -> (UserInfoExt);
   deleteAccount: (principal) -> (bool);
   getAllTokens: () -> (vec TokenInfoExt) query;
   getTokenInfo: (text) -> (TokenInfoExt) query;
   getUserInfo: (principal) -> (opt UserInfoExt) query;
   logoToken: () -> (text) query;
   mintCloneNFT: (text, text) -> (TokenInfoExt);
   mintNFT: (TokenInfoExt) -> (TokenInfoExt);
   mintToken: (principal, nat) -> (TxReceipt);
   nameToken: () -> (text) query;
   readAccount: () -> (vec UserInfoExt) query;
   symbolToken: () -> (text) query;
   transferToken: (principal, nat) -> (TxReceipt);
   transferTokenFrom: (principal, principal, nat) -> (TxReceipt);
   updateAccount: (principal, text, text, nat, text, text, text) ->
    (UserInfoExt);
 };
service : (principal) -> NFTSale
